#!/usr/bin/env npx tsx
/**
 * í”„ë¦¬ë·° ë³´ê³ ì„œ ìƒì„± ìŠ¤í¬ë¦½íŠ¸
 *
 * ì‚¬ìš©ë²•:
 *   npx tsx scripts/generate-preview.mts           # ìµœê·¼ ì´ˆì•ˆì˜ í”„ë¦¬ë·° ìƒì„±
 *   npx tsx scripts/generate-preview.mts --today   # ì˜¤ëŠ˜ ìƒì„±ëœ ì´ˆì•ˆë§Œ
 */

import { config } from 'dotenv';
config();

import { readdir, readFile, mkdir, writeFile, stat } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import chalk from 'chalk';
import matter from 'gray-matter';

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = join(__dirname, '..');

interface DraftInfo {
  filename: string;
  filepath: string;
  title: string;
  type: string;
  tags: string[];
  draft: boolean;
  date: string;
  description: string;
  coverImage?: string;
  hasInlineImages: boolean;
  inlineImageCount: number;
  wordCount: number;
  createdAt: Date;
}

async function getDrafts(todayOnly: boolean): Promise<DraftInfo[]> {
  const draftsDir = join(projectRoot, 'drafts');

  try {
    await stat(draftsDir);
  } catch {
    return [];
  }

  const files = await readdir(draftsDir);
  const mdFiles = files.filter(f => f.endsWith('.md'));

  const drafts: DraftInfo[] = [];
  const today = new Date().toISOString().split('T')[0];

  for (const filename of mdFiles) {
    const filepath = join(draftsDir, filename);
    const content = await readFile(filepath, 'utf-8');
    const fileStat = await stat(filepath);
    const { data, content: body } = matter(content);

    // ì¸ë¼ì¸ ì´ë¯¸ì§€ ì¹´ìš´íŠ¸
    const imageMatches = body.match(/!\[.*?\]\(.*?\)/g) || [];
    const hasInlineImages = imageMatches.length > 0;

    const draftInfo: DraftInfo = {
      filename,
      filepath,
      title: data.title || filename,
      type: data.categories?.[0] || 'unknown',
      tags: data.tags || [],
      draft: data.draft !== false,
      date: data.date || '',
      description: data.description || '',
      coverImage: data.image,
      hasInlineImages,
      inlineImageCount: imageMatches.length,
      wordCount: body.length,
      createdAt: fileStat.mtime
    };

    if (todayOnly) {
      const fileDate = fileStat.mtime.toISOString().split('T')[0];
      if (fileDate === today) {
        drafts.push(draftInfo);
      }
    } else {
      drafts.push(draftInfo);
    }
  }

  // ìµœì‹ ìˆœ ì •ë ¬
  drafts.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

  return drafts;
}

async function generatePreviewReport(drafts: DraftInfo[]): Promise<string> {
  const today = new Date().toISOString().split('T')[0];
  const time = new Date().toLocaleString('ko-KR');

  let report = `# í¬ìŠ¤íŠ¸ í”„ë¦¬ë·° ë³´ê³ ì„œ

**ìƒì„± ë‚ ì§œ**: ${today}
**ìƒì„± ì‹œê°„**: ${time}
**ì´ˆì•ˆ ìˆ˜**: ${drafts.length}ê°œ

---

`;

  if (drafts.length === 0) {
    report += '> í”„ë¦¬ë·°í•  ì´ˆì•ˆì´ ì—†ìŠµë‹ˆë‹¤.\n';
    return report;
  }

  for (const draft of drafts) {
    const emoji = draft.type === 'travel' ? 'ğŸ§³' : 'ğŸ¨';
    const statusEmoji = draft.draft ? 'ğŸ“' : 'âœ…';

    report += `## ${emoji} ${draft.title}

| í•­ëª© | ê°’ |
|------|------|
| **íŒŒì¼ëª…** | \`${draft.filename}\` |
| **ìœ í˜•** | ${draft.type} |
| **ìƒíƒœ** | ${statusEmoji} ${draft.draft ? 'ì´ˆì•ˆ' : 'ë°œí–‰ ì¤€ë¹„'} |
| **ì‘ì„±ì¼** | ${draft.date || 'ë¯¸ì§€ì •'} |
| **ê¸€ì ìˆ˜** | ${draft.wordCount.toLocaleString()}ì |
| **ì»¤ë²„ ì´ë¯¸ì§€** | ${draft.coverImage ? 'âœ… ìˆìŒ' : 'âŒ ì—†ìŒ'} |
| **ì¸ë¼ì¸ ì´ë¯¸ì§€** | ${draft.hasInlineImages ? `âœ… ${draft.inlineImageCount}ê°œ` : 'âŒ ì—†ìŒ'} |

### ì„¤ëª…
${draft.description || '(ì„¤ëª… ì—†ìŒ)'}

### íƒœê·¸
${draft.tags.length > 0 ? draft.tags.map(t => `\`${t}\``).join(' ') : '(íƒœê·¸ ì—†ìŒ)'}

### ì˜ˆìƒ URL
\`/posts/${draft.date ? String(draft.date).slice(0, 7).replace('-', '/') : 'YYYY/MM'}/${draft.filename.replace('.md', '')}/\`

---

`;
  }

  // ìš”ì•½
  const travelCount = drafts.filter(d => d.type === 'travel').length;
  const cultureCount = drafts.filter(d => d.type === 'culture').length;
  const totalImages = drafts.reduce((sum, d) => sum + d.inlineImageCount + (d.coverImage ? 1 : 0), 0);

  report += `## ğŸ“Š ìš”ì•½

| í•­ëª© | ìˆ˜ëŸ‰ |
|------|------|
| Travel í¬ìŠ¤íŠ¸ | ${travelCount}ê°œ |
| Culture í¬ìŠ¤íŠ¸ | ${cultureCount}ê°œ |
| ì´ ì´ë¯¸ì§€ | ${totalImages}ê°œ |

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

1. ê° ì´ˆì•ˆ ë‚´ìš© ê²€í† 
2. ë¡œì»¬ ë¯¸ë¦¬ë³´ê¸°: \`npm run hugo:serve\`
3. ìˆ˜ì • í•„ìš”ì‹œ: ì§ì ‘ íŒŒì¼ í¸ì§‘
4. ë°œí–‰: \`npm run daily:deploy\`

---
*Generated by OpenClaw Preview Generator*
`;

  return report;
}

async function main() {
  const args = process.argv.slice(2);
  const todayOnly = args.includes('--today');

  console.log(chalk.cyan('\nğŸ“‹ í”„ë¦¬ë·° ë³´ê³ ì„œ ìƒì„±\n'));

  // ì´ˆì•ˆ ìˆ˜ì§‘
  const drafts = await getDrafts(todayOnly);

  console.log(chalk.dim(`  ë°œê²¬ëœ ì´ˆì•ˆ: ${drafts.length}ê°œ`));

  if (drafts.length === 0) {
    console.log(chalk.yellow('\nâš ï¸ í”„ë¦¬ë·°í•  ì´ˆì•ˆì´ ì—†ìŠµë‹ˆë‹¤.'));
    if (todayOnly) {
      console.log(chalk.dim('  --today ì˜µì…˜ ì—†ì´ ë‹¤ì‹œ ì‹¤í–‰í•´ë³´ì„¸ìš”.'));
    }
    process.exit(0);
  }

  // ë³´ê³ ì„œ ìƒì„±
  const report = await generatePreviewReport(drafts);

  // ì €ì¥
  const reportsDir = join(projectRoot, 'reports');
  await mkdir(reportsDir, { recursive: true });

  const today = new Date().toISOString().split('T')[0];
  const reportPath = join(reportsDir, `preview-${today}.md`);

  await writeFile(reportPath, report, 'utf-8');

  console.log(chalk.green(`\nâœ… ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ: ${reportPath}`));

  // ì½˜ì†”ì—ë„ ê°„ë‹¨ ìš”ì•½ ì¶œë ¥
  console.log(chalk.white.bold('\nğŸ“ ì´ˆì•ˆ ëª©ë¡:'));
  for (const draft of drafts) {
    const emoji = draft.type === 'travel' ? 'ğŸ§³' : 'ğŸ¨';
    const status = draft.draft ? chalk.yellow('ì´ˆì•ˆ') : chalk.green('ë°œí–‰ì¤€ë¹„');
    console.log(`  ${emoji} ${draft.title}`);
    console.log(chalk.dim(`     ${status} | ${draft.wordCount.toLocaleString()}ì | ì´ë¯¸ì§€ ${draft.inlineImageCount + (draft.coverImage ? 1 : 0)}ê°œ`));
  }

  console.log(chalk.cyan('\nğŸ’¡ ìì„¸í•œ ë‚´ìš©ì€ ë³´ê³ ì„œë¥¼ í™•ì¸í•˜ì„¸ìš”.'));
}

main().catch((err) => {
  console.error(chalk.red('ì˜¤ë¥˜:'), err);
  process.exit(1);
});
